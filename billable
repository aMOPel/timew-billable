#! /usr/bin/python

from functools import reduce
from datetime import datetime
import locale
import json
import sys

DATEFORMAT = "%Y%m%dT%H%M%SZ"
CONFIG_DEFAULTS = {
    "project_marker": "#", "separator": ".",
    "billable": 0, "description_marker": None,
    "locale": ''
}


def coerce_float(someval):
    try:
        return float(someval)
    except ValueError:
        return someval


def to_config_dict(cdict, line):
    """
    Reduce a list of configuration lines into a configuration dictionary of
    relavent configurations for reporting.
    """
    kvpair = line.split(": ", 2)
    conf_keys = kvpair[0].split(".")
    if conf_keys[0] != "billable":
        return cdict

    key = conf_keys[0] if len(conf_keys) < 2 else conf_keys[1]
    cdict[key] = coerce_float(kvpair[1])

    return cdict


def create_levels(entry, conf, time=0):
    """ Recursively create nested Project: Task relationships. """
    pass


def not_metadata(tag, config):
    """ Test a tag to make sure it's not a piece of meta-data. """
    return tag not in config and not tag.startswith(config["project_marker"])


def take_first(pred, list):
    """ Grab the first item from a filtered list """
    return next(filter(pred, list), None)


def get_billable_hours(entry):
    """ Get the time spent, and billable hours for an entry """
    start = datetime.strptime(entry["start"], DATEFORMAT)

    if "end" in entry:
        end = datetime.strptime(entry["end"], DATEFORMAT)
    else:
        end = datetime.utcnow()

    tracked = end - start
    hours = round(tracked.total_seconds() / pow(60, 2), 2)
    return (tracked, hours)


def get_rate(entry, config):
    """
    Find the contextual billable rate for a task.
    """
    expected_keys = CONFIG_DEFAULTS.keys()

    for tag in entry["tags"]:
        if tag not in expected_keys:
            rate = config.get(tag, None)
            if rate:
                return rate

    return config["billable"]


def update_tasks(tasks, task):
    """
    Recursively update the tasks list and apply new time data to existing
    projects, or add and update missing projects.
    """
    print(task)
    pass


def organize_subtasks(data):
    """
    Build a hierarchical dictionary of tasks and related subtasks.

    Parameters:
        entries: A list of timewarrior entries.
    Returns:
        A nested dictionary of tasks/subtasks.
    """
    config, entries = data
    tasks = []
    for entry in entries:
        hierarchy = []
        tags = entry["tags"]

        dmarker = config["description_marker"]
        if dmarker:
            task = take_first(lambda t: t.startswith(dmarker), tags)
        else:
            task = take_first(lambda t: not_metadata(t, config), tags)

        if dmarker and not task:
            task = take_first(lambda t: not_metadata(t, config), tags)

        if not task:
            continue

        # Find Project.category tree.
        pmarker = config["project_marker"]
        project_tree = take_first(lambda t: t.startswith(pmarker), tags)

        if project_tree:
            hierarchy.append(*project_tree[1:].split(config["separator"]))

        hierarchy.append(task)
        billables = get_billable_hours(entry)
        rate = get_rate(entry, config)
        task = [hierarchy, billables, rate]
        tasks = update_tasks(tasks, task)


def parse_lines(stdin):
    """
    Parse stdin into a tuple of dictionaries.

    Parameters:
        stdin (sys.stdin): Standard input.

    Returns:
        tuple: Parsed data: (config setting, parsed time entries)
    """
    lines = [ln.strip() for ln in stdin]
    config_lines = lines[:lines.index("")]
    entries_json = "".join(lines[lines.index("") + 1:])

    configs = reduce(to_config_dict, config_lines, CONFIG_DEFAULTS)
    entries = json.loads(entries_json)
    print(configs)
    return (configs, entries)


def generate_report(data):
    lines = organize_subtasks(data)


if __name__ == "__main__":
    data = parse_lines(sys.stdin)
    locale.setlocale(locale.LC_ALL, data[0]["locale"])
    generate_report(data)
