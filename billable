#! /usr/bin/python

from functools import reduce
from datetime import datetime
import locale
import json
import sys

DATEFORMAT = "%Y%m%dT%H%M%SZ"
CONFIG_DEFAULTS = {
    "project_marker": "#", "separator": ".",
    "billable": 0, "description_marker": None,
    "locale": ''
}


def coerce_float(someval):
    try:
        return float(someval)
    except ValueError:
        return someval


def to_config_dict(cdict, line):
    """
    Reduce a list of configuration lines into a configuration dictionary of
    relavent configurations for reporting.
    """
    kvpair = line.split(": ", 2)
    conf_keys = kvpair[0].split(".")
    if conf_keys[0] != "billable":
        return cdict

    key = conf_keys[0] if len(conf_keys) < 2 else conf_keys[1]
    cdict[key] = coerce_float(kvpair[1])

    return cdict


def not_metadata(tag, config):
    """ Test a tag to make sure it's not a piece of meta-data. """
    return tag not in config and not tag.startswith(config["project_marker"])


def take_first(pred, list):
    """ Grab the first item from a filtered list """
    return next(filter(pred, list), None)


def get_billable_hours(entry):
    """ Get the time spent, and billable hours for an entry """
    start = datetime.strptime(entry["start"], DATEFORMAT)

    if "end" in entry:
        end = datetime.strptime(entry["end"], DATEFORMAT)
    else:
        end = datetime.utcnow()

    tracked = end - start
    hours = round(tracked.total_seconds() / pow(60, 2), 2)
    return (tracked, hours)


def get_rate(entry, config):
    """
    Find the contextual billable rate for a task.
    """
    expected_keys = CONFIG_DEFAULTS.keys()

    for tag in entry["tags"]:
        if tag not in expected_keys:
            rate = config.get(tag, None)
            if rate:
                return rate

    return config["billable"]


def update_row_data(rows, task):
    """
    Apply task data to some table row data and its descendent children.

    Parameters:
        rows (list): The current nested list of table row data.
        task (tuple): The current task which contains the task
            hierarchy, a tuple of billable hours and the billable rate.
    Returns:
        rows (list): The updated data rows.
    """
    levels, billable, rate = task
    _tracked, hours = billable
    level, *nested = levels
    row = -1

    for i, t in enumerate(rows):
        if t[0] == level:
            row = i
            break

    if row > -1:
        rows[row][1] += hours
    else:
        rows.append([level, hours, []])
        row = len(rows) - 1

    if nested:
        next = (nested, billable, rate)
        rows[row][2] = update_row_data(rows[row][2], next)

    return rows


def organize_subtasks(data):
    """
    Build a hierarchical dictionary of tasks and related subtasks.

    Parameters:
        data (tuple): A tuple containing relevant configs and data
        entries
    Returns:
        A list of nested table row data.
    """
    config, entries = data
    rows = []
    for entry in entries:
        hierarchy = []
        tags = entry["tags"]

        dmarker = config["description_marker"]
        if dmarker:
            task = take_first(lambda t: t.startswith(dmarker), tags)
        else:
            task = take_first(lambda t: not_metadata(t, config), tags)

        if dmarker and not task:
            task = take_first(lambda t: not_metadata(t, config), tags)

        if not task:
            continue

        # Find Project.category tree.
        pmarker = config["project_marker"]
        project_tree = take_first(lambda t: t.startswith(pmarker), tags)

        if project_tree:
            hierarchy.append(*project_tree[1:].split(config["separator"]))

        hierarchy.append(task)
        billables = get_billable_hours(entry)
        rate = get_rate(entry, config)
        task = (hierarchy, billables, rate)
        rows = update_row_data(rows, task)

    return rows


def parse_lines(stdin):
    """
    Parse stdin into a tuple of dictionaries.

    Parameters:
        stdin (sys.stdin): Standard input.

    Returns:
        tuple: Parsed data: (config setting, parsed time entries)
    """
    lines = [ln.strip() for ln in stdin]
    config_lines = lines[:lines.index("")]
    entries_json = "".join(lines[lines.index("") + 1:])

    configs = reduce(to_config_dict, config_lines, CONFIG_DEFAULTS)
    entries = json.loads(entries_json)
    return (configs, entries)


def generate_report(data):
    row_data = organize_subtasks(data)
    print(row_data)


if __name__ == "__main__":
    data = parse_lines(sys.stdin)
    locale.setlocale(locale.LC_ALL, data[0]["locale"])
    generate_report(data)
